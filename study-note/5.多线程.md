1.一个`Thread`实例可以通过`t.setDaemon`设置该线程为守护线程.  当所有非守护线程退出后, 守护线程也会结束. 

2.`Runnable`抛出异常或正常结束, 都会使得该线程终止.

3.`Java`并不保证线程会被平等对待和调度.但支持设置优先级(1-10)以影响线程的调度工作. 默认和创建该线程的优先级一致. 优先级可以动态的改变. 当线程数过多时, 调度程序**通常**会偏向运行优先级较高的线程, 取决于`JVM`平台的实现. 优先级应该用来表示不同线程间的紧急程度. 10: 关键问题  7-9: 交互, 事件驱动 4-6: IO相关 2-3: 后台计算

4.每个线程都有一个对应的中断状态, 使用`Thread`实例的`t.interrupt`方法将中断状态改`true`. 在使用如下方法时:`wait`,`join`,`sleep`中断状态会被设为`false`并抛出异常. 通过`t.isInterrupted`, 获取中断状态不会将中断状态改为`false`. 使用静态方法`Thread.interrupted`会返回清除当前线程的中断状态, 并清除状态.

5.使用`Thread`实例的`t.join`会将调用者挂起, 知道`t`线程执行完毕. 调用一个未启动或者未创建的线程的`join`方法没有任何意义.

6.`Thread`中申明为静态的方法都是对该线程有效.

7.`Thread.yield`仅仅是一个建议, 告诉`JVM`可以放弃当前线程而去运行其他线程.

8.通常而言, 并发可以是一个同时处理多个任务的程序, 抽象的定义: `JVM`和操作系统提供了从表面的同时性到物理的并行性的映射(通过多`CPU`). 这个映射可以通过并行的执行独立的操作来完成, 或者通过分时系统.

9.进程表示一个单独的运行程序. 大多数系统使用抢占型时间片调度: 定期挂起进程以便给其他进程运行机会.

10.线程带来的问题:  1.安全性问题. 2. 活跃性问题. 3.性能问题.

11.三种修复多线程的方法: 1.不在线程间共享. 2. 使用final变量. 3.使用同步.

12.多个线程访问某个类, 该类始终能表现正确的行为. 那么这个类就是线程安全的.

13. `countDownLatch`用于等待事件, 而另一个用于等待其他线程.
14. 线程池具有平缓关闭和暴力关闭.
15. `vmstat 1` 观察`cs`得知每秒切换次数
16. 减少上下文切换的方法: 无锁编程, `CAS`算法 使用最少线程 使用协程.
17. `volatile`有两个作用: 将缓存数据写入内存.   使其他处理器中的缓存数据无效,嗅探技术(`MESI 修改,独占, 共享,无效`).
18. 对象头存有`markword`, 类型数据指针, 数组长度
19. `markword`存储锁信息, 分代年龄, `hashCode`.
20. 偏向锁为指向线程id, 轻量级锁在线程中开辟记录空间,并复制`markword` 同时锁对象指向该空间
21. 编译器不会对存有数据依赖性的代码进行重排序.
22. 编译器必须遵守as-if-serial规则, 也就是物理怎么重排序,结果不能改变.
23. daemon线程的finally不会执行.