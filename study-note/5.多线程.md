1.一个`Thread`实例可以通过`t.setDaemon`设置该线程为守护线程.  当所有非守护线程退出后, 守护线程也会结束. 

2.`Runnable`抛出异常或正常结束, 都会使得该线程终止.

3.`Java`并不保证线程会被平等对待和调度.但支持设置优先级(1-10)以影响线程的调度工作. 默认和创建该线程的优先级一致. 优先级可以动态的改变. 当线程数过多时, 调度程序**通常**会偏向运行优先级较高的线程, 取决于`JVM`平台的实现. 优先级应该用来表示不同线程间的紧急程度. 10: 关键问题  7-9: 交互, 事件驱动 4-6: IO相关 2-3: 后台计算

4.每个线程都有一个对应的中断状态, 使用`Thread`实例的`t.interrupt`方法将中断状态改`true`. 在使用如下方法时:`wait`,`join`,`sleep`中断状态会被设为`false`并抛出异常. 通过`t.isInterrupted`, 获取中断状态不会将中断状态改为`false`. 使用静态方法`Thread.interrupted`会返回清除当前线程的中断状态, 并清除状态.

5.使用`Thread`实例的`t.join`会将调用者挂起, 知道`t`线程执行完毕. 调用一个未启动或者未创建的线程的`join`方法没有任何意义.

6.`Thread`中申明为静态的方法都是对该线程有效.

7.`Thread.yield`仅仅是一个建议, 告诉`JVM`可以放弃当前线程而去运行其他线程.

8.通常而言, 并发可以是一个同时处理多个任务的程序, 抽象的定义: `JVM`和操作系统提供了从表面的同时性到物理的并行性的映射(通过多`CPU`). 这个映射可以通过并行的执行独立的操作来完成, 或者通过分时系统.

9.进程表示一个单独的运行程序. 大多数系统使用抢占型时间片调度: 定期挂起进程以便给其他进程运行机会.

10.线程带来的问题:  1.安全性问题. 2. 活跃性问题. 3.性能问题.

11.三种修复多线程的方法: 1.不在线程间共享. 2. 使用final变量. 3.使用同步.

12.多个线程访问某个类, 该类始终能表现正确的行为. 那么这个类就是线程安全的.

13. `countDownLatch`用于等待事件, 而另一个用于等待其他线程.

14. 线程池具有平缓关闭和暴力关闭.

15. `vmstat 1` 观察`cs`得知每秒切换次数

16. 减少上下文切换的方法: 无锁编程, `CAS`算法 使用最少线程 使用协程.

17. `volatile`有两个作用: 将缓存数据写入内存.   使其他处理器中的缓存数据无效,嗅探技术(`MESI 修改,独占, 共享,无效`).

18. 对象头存有`markword`, 类型数据指针, 数组长度

19. `markword`存储锁信息, 分代年龄, `hashCode`.

20. 偏向锁为指向线程id, 轻量级锁在线程中开辟记录空间,并复制`markword` 同时锁对象指向该空间

21. 编译器不会对存有数据依赖性的代码进行重排序.

22. 编译器必须遵守as-if-serial规则, 也就是物理怎么重排序,结果不能改变.

23. daemon线程的finally不会执行.

24. Thread的停止方法不保证资源的正确释放.

25. `Synchronized`锁再等待时无法被中断, 获取到锁时才能被中断.

26. Lock与`Synchronized`的区别: 中断, 超时获取. 自旋锁, 灵活度

27. `CountDownLatch`为0 , await不会阻塞. wait(0)表示一直等待下去.

28. 线程池参数: 

    `corePoolSize` –保留在池中的线程数（即使它们处于空闲状态），除非设置了`allowCoreThreadTimeOut`
    `maximumPoolSize` –池中允许的最大线程数
    `keepAliveTime` –当线程数大于内核数时，这是多余的空闲线程将在终止之前等待新任务的最长时间。
    `unit – keepAliveTime`参数的时间单位
    `workQueue` –用于在执行任务之前保留任务的队列。 此队列将仅保存execute方法提交的Runnable任务。
    `threadFactory` –执行程序创建新线程时要使用的工厂
    `handler` –因达到线程边界和队列容量而被阻止执行时使用的处理程序

    ​	拒绝策略有: `CallerRunsPolicy`: 使用调用者线程来执行被拒绝的任务.

    ​							`AbortPolicy`: 抛出异常.

    ​						`DiscardPolicy`: 直接丢弃被拒绝的任务.

    ​						`DiscardOldestPolicy`: 丢弃下一个要执行的队列任务,  然后重新执行.
    
29. 线程池`ctl` 是一个原子整数，它包装了两个概念字段`workerCount`指示了线程的有效数量,`runState`指示了是否运行，关闭等. `workerCount`是允许启动和不允许停止的工人的数量 高3位位线程状态标识, 低29位为线程数量

    线程池原理:

     1. 判断当前线程是否小于核心线程数:

    ​	1.线程不为null:添加线程进队列, 循环`cas`添加线程数量. 运行线程, 运行线程前有一个钩子函数.

    ​		抛出异常有一个钩子函数. 执行完成删除works内的当前任务.

    ​	2.线程为空: 删除线程计数, 

    以上执行成功便结束了,  失败可能由以下情况: 

    ​         1.线程池状态不符合. 

    ​		 2.线程池线程数量过多. 

    2. 判断线程池是否在运行状态, 将任务添加进阻塞队列.
       1. 以上两个成功:
          1. 如果线程池不处于运行状态, 则队列移除任务, 并且对移除的任务执行拒绝策略.
          2. 线程池处于运行状态, 将会运行线程队阻塞队列里的任务(每个worker执行完后会将自己的task置空, 然后循环从阻塞队列获取).
       2. 其中一个失败:
          1. 则再次尝试执行, 如果还是失败则执行拒绝策略.
       
       当前线程数量大于核心线程数就是可回收线程.
    
30. `Future`表示异步计算的结果, `FutureTask`就是使用`CAS`改变状态值进行控制

31. 线程池中的任务在执行前是不允许中断, 为什么用实现的不可重入锁是为了在`setCorePoolSize`等方法时避免获取锁.避免被中断清理.

32. 阻塞队列: 

    1. `ArrayBlockQueue`: 经典的FIFO有界阻塞队列,内部原理使用`lock+condition`  基于数组
    2. `PriorityBlockQueue`: 优先级队列, 需要实现`Comparator`接口, 无界阻塞队列, 虽然是数组, 但是因为有扩容机制, 所以无界.
    3. `LinkedBlockQueue` 可选的有界单向链表FIFO阻塞队列.
    4. `LinkedBlockingDeque`可选的有界双向链表的阻塞队列.

