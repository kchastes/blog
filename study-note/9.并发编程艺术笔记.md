> 《并发编程艺术》笔记

# 并发编程挑战

所涉及到的知识点：

1. 单核线程通过分配`CPU`时间片来实现多线程机制，线程切换的过程就叫做上下文切换。

2. 并发不一定比串行快，在任务量少时，可能由于上下文切换所带来的资源消耗拖累并发速度。

3. 减少上下文切换的方式：
  - 无锁并发编程，例如数据分段处理，不同线程处理不同段。
  - `CAS`算法：使用`CAS`算法更新数据，不需要加锁。
  - 非必要不要使用线程。
  - 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

4. 实战：

  ```she
  jstack 2519 > /tmp/dump17 # jump出线程信息
  grep java.lang.Thread.State dump17 | awk '{print $2$3$4$5}' | sort | uniq -c # 统计所有线程分别处于什么状态
  ```

5. 避免死锁方式：

  - 避免单个线程同时获取多个锁。
  - 避免在所内占用多个资源。
  - 尝试使用定时锁。

6. 资源限制：如果网速只有1Mb/s，开10个线程也不会变成10Mb/s，同时会增加上下文切换和资源调度的时间。

# Java并发底层原理

`Java`中所使用的并发机制依赖于`JVM`的实现和`CPU`的指令。

1. `volatile`保证内存可见性。在`Java`内存模型会确保所有线程看到一致的`volatile`变量值。原理在于加了`Volatile`标识的代码会多出一行`lock`汇编指令，该指令效果：将缓存行数据写回内存，同时使其他`cpu`缓存的数据无效。（依赖于缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态）

2. 追加字节避免头尾节点在同一缓存行中，从而影响写性能。这类优化只针对特定处理器，同时如果不是频繁的写，造成的性能影响不大，反而会带来读取更多的字节到缓存行中的性能影响。

3. `Synchonized`，代码块同步是使用`monitorenter`和`monitorexit`指令实现的，`monitorenter`指令是在编译后插入到同步代码块的开始位置，而`monitorexit`是插入到方法结束处和异常处(防止抛出异常锁未释放)。任何对象都有一个`monitor`与之关联。

   1. 对于普通同步方法，锁是当前实例对象。
   2. 对于静态同步方法，锁是当前类的Class对象。
   3. 对于同步方法块，锁是`Synchonized`括号里配置的对象。

   锁是存在对象头中的`Mark Word`中，存储的数据会随着锁标志位的变化而变化。

4. 偏向锁：基于锁一般由同一线程多次获得这一理论，偏向锁就是为了降低获取锁的代价。偏向锁会在对象头和栈帧中的锁记录里存储锁偏向的线程`ID`，通过这一属性区分锁释放偏向某一线程。

5. 轻量级锁会在当前线程的栈帧中创建锁记录空间，将对象头的`mark word`复制到该空间中，然后线程会将`mark word`替换为锁记录的指针，成功则加锁成功，失败则自旋重试。当存在锁竞争时会升级为重量级锁。重量级锁是阻塞等待，轻量级锁是自旋，适合同步代码执行快的程序(不容易形成竞争，就不会升级为重量级锁)

6. `Java`中的`CAS`就是使用了`CMPXCHG`命令。`CAS`存在的问题：

   - `ABA`问题：`A->B->A`此时会觉得并没有发生变化，通过版本号解决，`Java`中提供了`AtomicStampedReference`。
   - 循环时间大：如果长时间不成功，将会一直自旋，CPU消开销大。
   - 只能保证一个共享变量的原子操作。取巧办法：合并变量。`Java`提供了`AtomicReference`保证引用对象之间的原子性。

# Java内存模型

在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。`Java`使用的共享内存的方式进行线程间的通信和并发控制。

每个线程都有一个私有的本地内存，这是一个抽象概念，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。重排序分3种类型。

1. 编译器重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级并行重排序：现代处理器采用了指令级并行技术（`Instruction-Level Parallelism，ILP`）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

`JMM`的编译器重排序规则会禁止特定类型的编译器重排序，对于处理器重排序，`JMM`通过内存屏障指令来禁止特定类型的处理器重排序。

`happens-before`的概念来阐述操作之间的内存可见性，该规则只是为了让程序员更好理解内存可见性规则。

不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。顺序一致性内存模型是一个理论参考模型

`volatile`变量自身具有下列特性：

1. 可见性：对一个`volatile`变量的读，总是能看到（任意线程）对这个`volatile`变量最后的写入。
2. 原子性：对任意单个`volatile`变量的读/写具有原子性，但类似于`volatile++`这种复合操作不具有原子性。

当写一个`volatile`变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。

Java线程状态由Thread.State内部类表示：

1. `NEW`：线程被构建没有调用`start()`。
2. `RUNNABLE`：运行状态。
3. `BLOCKED`：阻塞状态
4. `WAITING`：等待状态，需要其他线程做一些动作（通知或中断）。
5. `TIME_WAITING`：超时等待状态。
6. `TERMINATED`：终止状态。

不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下
