> Spring文档学习记录,也算是部分翻译吧.分节根据官方项目分节,代码案例放到了`spring-combination`仓库

# Spring Framework

`Spring Framework`是`Spring Projects`的基础,那么肯定从这里出发.

## Overview

使用`Spring`使得创建`Java`企业级应用变得更加简单.从`Spring Framework 5 .1`开始,Spring需要JDK 8+(Java SE 8+).

Spring框架分为多个模块.应用程序可以选择所需的模块.核心容器的模块是`core`,包括`Configuration model`和`dependency injection mechanism(依赖注入机制)`.

`Spring`实际上是`Java EE`的补充,它从`Java EE`中挑选部分规范集成在一起.

## Core

这一部分包含了`Spring`框架绝对必要的所有技术.

### IoC容器

`IoC`(控制反转),`Spring`采用的是使用`DI(依赖注入)`实现控制反转.`BeanFactory`接口提供了高级配置机制,使得它能够管理任何类型的对象,`ApplicationContext`则是它的子接口,它提供了更多特性,诸如: 与`Spring AOP`功能的集成,国际化,事件发布等.在`Spring`中,由`Spring IoC`容器管理的对象称为`bean`. `Bean`是由`Spring IoC`容器实例化,组装和管理的对象.`Bean`及其之间的依赖关系反映在容器使用的配置元数据中.

`ApplicationContext`接口代表着`IoC`容器,通过读取配置元数据实例化,配置和组装`bean`,配置元数据可以是`XML`,`Java`注解或者是`Java`代码的方式.通常创建`ClassPathXmlApplicationContext`或`FileSystemXmlApplicationContext`,尽管这些是传统方式,但是可以在`XML`中进行少量配置以开启`Java`代码或注解的方式.

`XML`中导入其他`XML`不建议使用`../image`这种方式,这种方式对上层产生依赖,如果上层发生改变则会出现不同的效果.也可以直接使用决定定位,但这耦合度太高了. 同时也不推荐使用`getBean`的方式去获取`bean`,这样依赖了`Spring`的API.

在容器内部,`bean`定义表现为`BeanDefinition`对象,包含以下信息:

1. 包全限定类名称.
2. `bean`的行为配置,作用域,生命周期等.
3. 依赖项.

除了使用`bean`定义信息外,还可以使用`ApplicationContext`获取`BeanFactory`,使用`BeanFactory`的`registerSingleton(..)`注册外部`bean`.每个`bean`都有具有一个或多个标识符,在同一个容器中只能有一个,如果需要多个,可以视为别名.`bean`可以在定义时使用`id`或name属性,`id`属性可以让你使用一个`id`,如果要添加别名,使用`name`属性,可以用`, `,`;`或空格进行分割,从而填写多个. 如果没有指定,则会生成一个默认的,但是在`ref`情况下,不可使用.命名规范,建议使用驼峰.使用`alias `标签可以组合`bean`.

默认使用`<bean/>`标签创建的`bean`使用的是构造函数,也可以使用`factory-method`指定静态方法创建.

依赖注入(DI)是一个过程,在这个过程中,对象仅通过构造函数参数、工厂方法的参数,或者在对象实例被构造或从工厂方法返回对象的属性来定义它们的依赖项.容器会在创建`bean`时注入这些依赖项.

使用DI的好处:代码更加清晰,对象不查找它的依赖项,也不知道依赖项的位置或类.解耦.

使用基于`set`的DI还是使用基于构造器的DI? 对于强制依赖项,使用构造器注入,对于可选的依赖项,使用`set`注入,这种方式时一个很好的经验法则.`Spring`官方推荐使用构造注入,因为构造所需的参数总是以完全态返回的.并确保所需的依赖项不为空,但是参数过多也影响代码美观.`Lombok`来了. `Set`注入主要好处就是可以重新赋值.

依赖性解析过程:

1. 创建ApplicationContext,并初始化所有元数据.
2. 存在依赖项,提供依赖项
3. 实际参数类型转换.

循环依赖问题: 可以通过将部分使用`set`注入,而不使用构造注入.ApplicationContext预先实例化bean的原因就是能够提早发现问题.也可以设置延迟初始化.

`depends-on`可以指定先于自身初始化时候的`bean`,在单例情况下,还指定了销毁顺序.`lazy-init`控制是否在请求时才创建指定`bean`.如果惰性`bean`是非惰性`bean`的依赖,则还是会初始化惰性`bean`

自动装配的好处: 

1. 显著的减少显示参数的必要.
2. 动态的更改配置,而不用修改原来的参数.

缺点:

1. 不能自动装配基本属性.显示配置总是会覆盖自动装配.
2. 可能存在不够精确的情况.
3. 如果对期望唯一类型依赖时,突然增加同种类型会出错.

有以下四种自动装配: 

1. `no`必须指明属性.
2. `byName`:根据属性同名进行查找.
3. `byType`:根据属性类型进行匹配,不能有多个,没有则未设置.`primary`为`true`指定为主要的
4. `constructor`:类似于`byType`,但是没有指定类型则会出错.

使用`autowire-candidate`设置为`false`,排除自动装配候选项,但是不影响按照名称进行匹配的.甚至可以使用`*demo`进行模式匹配.

对于在单例中要使用多多例`bean`,可以实现`ApplicationContextAwre`或者使用`Lookup`方式.

`bean`的作用域

1. `singleton`: 默认为单个实例对象.针对容器.
2. `prototype`: 容易数量的对象实例.
3. `request`:每个HTTP请求都有自己的bean实例,仅在`web`环境有效.
4. `session`: 将单个`bean`定义定义为HTTP会话的生命周期.
5. `application`:将单个`bean`定义定义为`ServletContext`的生命周期.
6. `WebSocket`:将单个`bean`定义定义为`WebSocket`的生命周期.