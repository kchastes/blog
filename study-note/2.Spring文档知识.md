> Spring文档学习记录,也算是部分翻译吧.分节根据官方项目分节,仅作为个人笔记,难免有些混乱.

# Spring Framework

`Spring Framework`是`Spring Projects`的基础,那么肯定从这里出发.

## Overview

使用`Spring`使得创建`Java`企业级应用变得更加简单.从`Spring Framework 5 .1`开始,Spring需要JDK 8+(Java SE 8+).

Spring框架分为多个模块.应用程序可以选择所需的模块.核心容器的模块是`core`,包括`Configuration model`和`dependency injection mechanism(依赖注入机制)`.

`Spring`实际上是`Java EE`的补充,它从`Java EE`中挑选部分规范集成在一起.

## Core

这一部分包含了`Spring`框架绝对必要的所有技术.

### IoC容器

`IoC`(控制反转),`Spring`采用的是使用`DI(依赖注入)`实现控制反转.`BeanFactory`接口提供了高级配置机制,使得它能够管理任何类型的对象,`ApplicationContext`则是它的子接口,它提供了更多特性,诸如: 与`Spring AOP`功能的集成,国际化,事件发布等.在`Spring`中,由`Spring IoC`容器管理的对象称为`bean`. `Bean`是由`Spring IoC`容器实例化,组装和管理的对象.`Bean`及其之间的依赖关系反映在容器使用的配置元数据中.

`ApplicationContext`接口代表着`IoC`容器,通过读取配置元数据实例化,配置和组装`bean`,配置元数据可以是`XML`,`Java`注解或者是`Java`代码的方式.通常创建`ClassPathXmlApplicationContext`或`FileSystemXmlApplicationContext`,尽管这些是传统方式,但是可以在`XML`中进行少量配置以开启`Java`代码或注解的方式.

`XML`中导入其他`XML`不建议使用`../image`这种方式,这种方式对上层产生依赖,如果上层发生改变则会出现不同的效果.也可以直接使用决定定位,但这耦合度太高了. 同时也不推荐使用`getBean`的方式去获取`bean`,这样依赖了`Spring`的API.

在容器内部,`bean`定义表现为`BeanDefinition`对象,包含以下信息:

1. 包全限定类名称.
2. `bean`的行为配置,作用域,生命周期等.
3. 依赖项.

除了使用`bean`定义信息外,还可以使用`ApplicationContext`获取`BeanFactory`,使用`BeanFactory`的`registerSingleton(..)`注册外部`bean`.每个`bean`都有具有一个或多个标识符,在同一个容器中只能有一个,如果需要多个,可以视为别名.`bean`可以在定义时使用`id`或name属性,`id`属性可以让你使用一个`id`,如果要添加别名,使用`name`属性,可以用`, `,`;`或空格进行分割,从而填写多个. 如果没有指定,则会生成一个默认的,但是在`ref`情况下,不可使用.命名规范,建议使用驼峰.使用`alias `标签可以组合`bean`.

默认使用`<bean/>`标签创建的`bean`使用的是构造函数,也可以使用`factory-method`指定静态方法创建.

依赖注入(DI)是一个过程,在这个过程中,对象仅通过构造函数参数、工厂方法的参数,或者在对象实例被构造或从工厂方法返回对象的属性来定义它们的依赖项.容器会在创建`bean`时注入这些依赖项.

使用DI的好处:代码更加清晰,对象不查找它的依赖项,也不知道依赖项的位置或类.解耦.

使用基于`set`的DI还是使用基于构造器的DI? 对于强制依赖项,使用构造器注入,对于可选的依赖项,使用`set`注入,这种方式时一个很好的经验法则.`Spring`官方推荐使用构造注入,因为构造所需的参数总是以完全态返回的.并确保所需的依赖项不为空,但是参数过多也影响代码美观.`Lombok`来了. `Set`注入主要好处就是可以重新赋值.

依赖性解析过程:

1. 创建ApplicationContext,并初始化所有元数据.
2. 存在依赖项,提供依赖项
3. 实际参数类型转换.

循环依赖问题: 可以通过将部分使用`set`注入,而不使用构造注入.ApplicationContext预先实例化bean的原因就是能够提早发现问题.也可以设置延迟初始化.

`depends-on`可以指定先于自身初始化时候的`bean`,在单例情况下,还指定了销毁顺序.`lazy-init`控制是否在请求时才创建指定`bean`.如果惰性`bean`是非惰性`bean`的依赖,则还是会初始化惰性`bean`

自动装配的好处: 

1. 显著的减少显示参数的必要.
2. 动态的更改配置,而不用修改原来的参数.

缺点:

1. 不能自动装配基本属性.显示配置总是会覆盖自动装配.
2. 可能存在不够精确的情况.
3. 如果对期望唯一类型依赖时,突然增加同种类型会出错.

有以下四种自动装配: 

1. `no`必须指明属性.
2. `byName`:根据属性同名进行查找.
3. `byType`:根据属性类型进行匹配,不能有多个,没有则未设置.`primary`为`true`指定为主要的
4. `constructor`:类似于`byType`,但是没有指定类型则会出错.

使用`autowire-candidate`设置为`false`,排除自动装配候选项,但是不影响按照名称进行匹配的.甚至可以使用`*demo`进行模式匹配.

对于在单例中要使用多多例`bean`,可以实现`ApplicationContextAwre`或者使用`Lookup`方式.

`bean`的作用域

1. `singleton`: 默认为单个实例对象.针对容器.
2. `prototype`: 容易数量的对象实例.
3. `request`:每个HTTP请求都有自己的bean实例,仅在`web`环境有效.
4. `session`: 将单个`bean`定义定义为HTTP会话的生命周期.
5. `application`:将单个`bean`定义定义为`ServletContext`的生命周期.
6. `WebSocket`:将单个`bean`定义定义为`WebSocket`的生命周期.

可以通过实现`InitializingBean`和`DisposableBean`实现生命周期回调. `@PostConstruct` 和`@PreDestroy`是对应的最佳实践.如果不想使用注解,还可以使用`init-method`和`destroy-method`属性指定方法.对象还可以自己实现`Lifecyle`接口,以便参与到容器的启动和关闭.设置完所有属性才进行调用,详情看后面的生命周期.优先级是:注解,接口,属性配置.`Aware`接口在构造,`set`执行之后执行,但是在`init`系列之前执行

子类可以继承父类多数属性,但是一些例外:depends on,autowire mode, dependency check, singleton, and lazy init.

BeanPostProcessor接口定义了回调方法, 您可以实现这些方法来提供您自己的(或覆盖容器的默认)实例化逻辑、依赖项解析逻辑, 等等. 如果您想在Spring容器完成实例化, 配置和初始化bean之后实现一些定制逻辑, 您可以插入一个或多个定制的BeanPostProcessor实现. 目前的顺序: 构造,set,aware,postprocessor,init.`BeanPostProcessor`需要及早实例化,以便可以应用到其他实例化对象.
`BeanFactoryPostProcessor`用于在`bean`实例化前操作`bean`配置元数据,如果需要配置实例化后的,建议使用前一个,如果用这个会导致过早实例化.

`Spring`扩展点: `Aware`,`BeanPostPropessor`,`BeanFactoryPostPropessor`,`FactoryBean`.`FactoryBean`接口是可插入到`Spring IoC`容器实例化逻辑中的一个点. 如果您有复杂的初始化代码(与冗长的XML代码相比, 它更适合用Java表达), 那么您可以创建自己的`FactoryBean`, 在该类中编写复杂的初始化, 然后将定制的`FactoryBean`插入到容器中. 加上`&`才能返回`FactoryBean`本身.

选择`Spring XML`配置还是使用`Java`注解? 视情况而定,`XML`可以在不修改目标组件源代码的情况下进行修改,而注解提供了更加简短的配置.使用`Java`代码配置可以不涉及目标组件源代码. `xml`会覆盖注解所配置的.如果只有一个构造函数, 将不需要`@Autowired`,如果有多个则需要指定. 也可以将`@Autowired`用于任意方法任意参数的情况和在字段上使用. 处理多个依赖选择的方法有: `@Primary`或者设置`autowiredCandidate`为`false`又或者使用`@Qualifier`限定范围.

`@Autowired`, `@Inject`, `@Value`和 `@Resource`,使用`BeanPostProcessor`实现,意味着你不能在自己的`BeanPostProcessor`中使用这些注解.当需要更多地控制选择过程时,可以使用`Spring`的`@Qualifier`注释,同时`@Qulifier`还可以用来进行分组.`CustomAutowireConfigurer`自定义`@Qualifier`注解.

`@Resource`默认注入`name`指定的类,没有则和`autowired`一样.

```xml
<!-- 动态配置类名 -->
<bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer">
    <property name="locations">
        <value>classpath:com/something/strategy.properties</value>
    </property>
    <property name="properties">
        <value>custom.strategy.class=com.something.DefaultStrategy</value>
    </property>
</bean>

<bean id="serviceStrategy" class="${custom.strategy.class}"/>
```

```java
// 自定义转换器
@Bean
public ConversionService conversionService() {
    DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
    conversionService.addConverter(new MyCustomConverter());
    return conversionService;
}
```



使用`@Service`之类的,而不使用`@Componet`可以在Spring框架的未来版本中携带额外的语义, 也可以用于切入点的目标.` @AliasFor`别名映射. 使用默认组件而不是`@Configuration`声明的`@Bean`方法没有被`CGLIB`增强.

将`@Bean`方法声明为静态的，这样就可以在不将包含它们的配置类创建为实例的情况下调用它们. 这在定义后处理器`bean`(例如, `BeanFactoryPostProcessor`或`BeanPostProcessor`类型)时特别有意义, 因为这些bean在容器生命周期的早期被初始化, 应该避免在那时触发配置的其他部分. `@Autowired`还支持泛型匹配.

可以使用`@Named`或者`ManagedBean`去代替`@Componet`,但是`JSR330`不能使用组合注解.`@Bean`指示实例化一个由`Spring`管理的实例. 一个`@Bean`没有在`@Configuration`中生命时,处于lite模式, 方法不能声明`bean`间的依赖关系,每个这样的方法实际上只是特定`bean`引用的工厂方法, 没有任何特殊的运行时语义.

`@Profiles`可以设置默认,激活了任意环境,默认的就会失效.`env.containsProperty("my-property");`默认配置两个`PropertySource`,一个时`JVM`系统属性(-D参数)级别的,一个是系统环境(环境变量)的,默认情况下`JVM`系统属性优先,并不会覆盖.自定义`PropertySource`由`MutablePropertySources`方法确定顺序.

`ReloadableResourceBundleMessageSource`国际化更加灵活,支持从`Spring`容易资源位置读取,同时支持热重新加载.

## Resources

使用新`Resources`的原因是因为,`JDK`自带的功能不全,扩展复杂.

## AOP

面向方面编程(AOP)是对面向对象编程(OOP)的补充, 它提供了考虑程序结构的另一种方式. 在OOP中模块化的关键单元是类, 而在AOP中模块化的单元是方面.Spring的一个关键组件是AOP框架. 虽然Spring IoC容器不依赖于AOP(这意味着如果您不想使用AOP就不需要使用), 但AOP补充了Spring IoC, 提供了一个功能非常强大的中间件解决方案. 

Spring AOP比使用完整的AspectJ更简单，因为不需要在开发和构建过程中引入AspectJ编译器/编织器。如果您只需要对Spring bean上的操作执行提出建议，那么Spring AOP是正确的选择。如果您需要通知不由Spring容器管理的对象(通常是域对象)，您需要使用AspectJ。如果希望通知除简单方法执行之外的连接点(例如，字段获取或设置连接点等)，还需要使用AspectJ