> 一些八股文问题回答!

# 1. Java篇

## 1. 基础篇

> 基础类问题,对于集合问题在其他文章

### 1. 为什么使用嵌套类?

1. 提高封装性: 可以访问内部私有属性, 同时内部类对外隐藏.
2. 易读和易于维护: 顶级类和小类更加接近.
3. 逻辑上对类进行分组: 一个类只在该类使用, 使用嵌套类使包更加流线性.

### 2. 为什么内部类不推荐实现`Serializable`?

Java 编译器进行合成结构,然而, 合成构造可能在不同的Java编译器实现中有所不同. 如果您序列化一个内部类, 然后用不同的`JRE`实现反序列化它, 可能会出现兼容性问题.

### 3.为什么Java不允许多继承?

为了避免状态多重继承的问题, 这是从多个类继承字段的能力. 例如, 假设您能够定义一个扩展多个类的新类. 当通过实例化该类创建对象时, 该对象将继承该类的所有超类的字段. 如果来自不同超类的方法或构造函数实例化同一个字段呢？哪个方法或构造函数将优先？因为接口不包含字段, 所以您不必担心状态多重继承引起的问题 .

### 4. 选择接口还是抽象类?

如果希望扩展你的类的类有许多共同的方法或字段, 可以考虑使用抽象类. 想利用多重继承或者想指定特定的行为, 但不关心谁来实现它. 考虑使用接口.

### 5. 遗留IO问题

1. 许多方法在失败时没有抛出异常，因此不可能获得有用的错误消息。例如，如果一个文件删除失败，程序将收到一个“删除失败”的提示，但不知道这是因为文件不存在，用户没有权限，或者有其他问题。

2. rename方法在不同平台上的工作不一致。

3. 没有对符号链接的真正支持。

4. 需要更多的元数据支持，比如文件权限、文件所有者和其他安全属性。

5. 访问文件元数据效率低下。

6. 许多文件方法无法扩展。在服务器上请求一个大型目录列表可能会导致挂起。大型目录还可能导致内存资源问题，从而导致拒绝服务。

7. 不可能编写可靠的代码来递归地遍历文件树，并在存在循环符号链接时做出适当的响应

## 2.`JVM`

### 1. `JVM`概述

`Java HotSpot`实现了Java虚拟机规范, 作为Java字节码执行引擎, 它在各种操作系统和架构上提供Java运行时设施, 如线程和对象同步. 它包括动态编译器, 可以自适应地将Java字节码编译成优化的机器指令, 并使用垃圾收集器有效地管理Java堆, 对低暂停时间和吞吐量进行优化. 它为剖析,监控和调试工具和应用程序提供数据和信息. 

甲骨文公司有两个主要的Java虚拟机`JVM`实现，即`Java HotSpot VM`和`Oracle JRockit JVM`, 并计划将这些代码和功能融合一起.

### 2. `JVM`虚拟机规范

1. 要正确实现 Java 虚拟机, 只需要能够读取类文件格式并正确执行其中规定的操作. 以防限制创建者的能力.
2. `returnAddress`类型的值是指向Java虚拟机指令操作码的指针.
3. 数值范围: 
   1. byte: -128到127, 8位1字节.
   2. short: -32768到32767, 16位2字节.
   3. int: -2147483648到2147483647, 32位四字节.
   4. long: -9223372036854775808到9223372036854775807 ,64位8字节.
   5. char: 0到65535, 16位无符号`UTF-16`.
4. Java编程语言中对布尔值进行操作的表达式被编译为使用int数据类型的值.用1来代表真,用0来代表假.
5. 每个Java虚拟机线程都有自己的`pc`(程序计数器)寄存器,存储的是指令地址, 如果是本地方法则为空.
6. 每个Java虚拟机线程都有一个私有的Java虚拟机栈, 与线程同时创建, Java虚拟机栈存储帧,它保存局部变量和动态链接, `returnAddress`, 栈的内存也不需要是连续的. 栈可以有固定大小, 也可以动态的扩展或收缩. 虚拟机的实现可以为用户提供大小控制. 没有空间创建线程抛出`OutOfMenoryError`, 一个线程没有足够的空间抛出`StackOverflowError`
7. 堆是运行时的数据区域, 所有的类实例和数组的内存都是从这里分配的. 堆可以是一个固定的大小, 也可以根据计算的需要进行扩展, 如果没有必要使用更大的堆, 也可以收缩. 堆的内存不需要是连续的, 没有特定的垃圾收集器. 没有足够的堆内存抛出``OutOfMenoryError`.
8. 方法区类似于传统语言的编译代码的存储区, 它存储每个类的结构, 如运行时常量池, 静态字段和方法数据, 以及方法和构造函数的代码, 包括用于类和实例初始化以及接口初始化的特殊方法. 没有足够的内存也会抛出 `OutOfMemoryError`
9. 本地方法栈和`java`栈类似, 不过存储的是本地方法. `Java`虚拟机实现不能加载本机方法, 如果本身不依赖传统栈, 就不需要提供本机方法栈. 如果提供, 本地方法栈通常在每个线程创建时分配给每个线程
10. 每个栈帧都有对当前方法类的运行时常量池的引用, 以及包含一个局部变量数组, long和double会占两个位置. 不能从n+1读到, 导致内容消失. 但是不要求实现者对64位对齐, 可以自由的决定值的表示方式. 还存有操作数栈, 用于保存结算结果.
11. 方法调用返回后恢复原栈帧的操作数栈和局部变量, 并适当增加程序计数器,以跳过方法调用.
12. 虚拟机并没有为对象规定任何特定的内部结构,有些是实现对类实例的引用是一个指向句柄的指针, 该句柄本身是一对指针: 一个指向包含对象方法的表和代表对象类型的类对象的指针, 另一个指向从堆中为对象数据分配的内存. 后续取消句柄变为直接指针.

### 3. `JVM`官网信息

1. `HotSpot`虚拟机使用两个字的对象头, 而经典虚拟机使用三个字的头像头. 第一个包含哈希代码和GC的状态信息, 第二个则是对对象的类的引用, 只有数组有第三个字, 表示数组大小.
2. client版`jvm`用于客户端快速启动, server版则强调长期运行.
3. 复制-清除收集器:  大多数对象是作为临时创建的, 当内存溢出时, 将少数存活的对象移动至另一区域. 对死亡的进行回收. 单线程.
4. Parallel Young: 复制清除技术, 不过利用了多线程的优势. 是`Server vm`默认的收集器. 当移动对象时, 会将相关的对象放在一起, 从而提高内存定位和缓存利用率. 
5. 标记-压缩: 该算法从根开始遍历活动对象的整个图，然后扫描内存，压缩死对象留下的间隙. 消除了内存碎片.
6. Parallel Old: 采用多线程的标记压缩方式清除旧内存区域, 减少标记暂停时间. 可以利用空闲处理器周期(或空闲处理器)收集大堆，同时在很短的时间内暂停应用程序线程。这是通过在执行应用程序线程时执行大量跟踪和清除工作来实现的.
7. Java库现在为经常使用的反射对象(如方法和构造函数)生成字节码存根。这种技术将反射调用公开给Java HotSpot编译器，从而产生更高的性能，并且在某些情况下，对于Server VM，完全消除了与反射调用相关的开销。这大大提高了反射密集型代码的速度，例如在序列化、RMI和CORBA代码环境中使用的代码。
8. 堆内存是从整个内存所需进行分配的.