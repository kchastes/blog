

# List

> 从这篇开始写关于`Java`容器相关的,主要分为三类:`List`,`Set`,`Map`.目前来看只会涉及主要的实现,但也不排除穿插'老家伙'的情况.

## 1.Collection

既然要写容器,那肯定先从`Collection`入手,`Collection`是`List`和`Set`的父接口.`Map`则是单独的接口.在这里提下`Collection`,后面就不再赘述了.

```java
public interface Collection<E> extends Iterable<E> {
```

`Collection`继承`Iterable`接口,实现了`Iterable`就表示允许该对象成为`for-each`的目标对象,者也是`Java`的一个语法糖.该类就包含一个个返回`Iterator`的方法和两个接口默认方法,具体可以自行查看.

`Collection`作为`List`,`Set`接口的根接口,并没有什么实质性的内容,只是定义了些通用方法用户在不同类型中传参,具体的内部细节有子类去掌控,如是否允许为空之类的.而且`JDK`也没有提供该接口的具体实现.

## 2. List

```java
public interface List<E> extends Collection<E> {
```

以上便是`List`接口的定义信息,从官方文档注释来看,`List`代表的是有序的集合,可以精确的控制每个元素的插入位置,可以通过整数索引获取指定位置的元素.并且允许重复,可以有多个`null`值或不为`null`,取决于具体的实现.

官方还提示了一点,在你不知道`List`的具体类型的情况下,迭代列表比通过索引获取更加可取.同时需要慎用通过索引获取元素,这将执行高代价的线性搜索.

## 3.ArrayLsit

### 1. 概览

`ArrayList`可以说是老大哥的存在,绝大部分情况下`List`实现首选,先看下结构:

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
```
先看下`ArrayList`所继承的类:
```java
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
```
`AbstractList`提供了`List`接口的基本实现,以减少使用随机访问(数组)实现`Lsit`接口所需的工作.

上一层

```java
public abstract class AbstractCollection<E> implements Collection<E> {
```

`AbstractCollection`提供了`Collection`的基本实现,以减少实现该接口所需要的工作.如果你只需要实现一个不可修改的集合,那么扩展该类即可,只需重写`iterator()`和`size()`即可,要实现可修改的,那么你还需要重写`add()`方法,因为该`add()`方法默认抛出异常.

`AsbtractCollection`和`AbstractList`的区别就是一个是针对需要实现`Collection`服务的,一个是针对使用数组实现`List`服务的.

再回到`ArrayList`,实现了`RandomAccess`接口,该接口只是一个标记接口,表示该类支持随机访问,在选择对应算法时就可以通过该接口选择合适的算法.`Cloneable`也是一个标记接口,表示该类支持使用`clone()`方法,如果没有实现`Cloneable`而去调用`clone()`则会产生`CloneNotSupportedException`异常.最后一个`Serializable`就不说了,相信大家都知道.

### 2.方法

上面提了一下`ArrayList`的类定义信息,这里我们先粗略的看一下基本熟悉:

```java
	/**
     * 默认初始容量
     */
    private static final int DEFAULT_CAPACITY = 10;
    /**
     * 慢性膨胀，和下面这个主要用去区分第一次膨胀的大小
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

    /**
     * 第一次膨胀为DEFAULT_CAPACITY
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     *	实际存储元素数组 transient不被序列化
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * 数组包含的元素数量
     * @serial
     */
    private int size;
```

刚开始令我疑惑的就是上面的`EMPTY_ELEMENTDATA`和`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`属性,为什么需要两个默认的空数组,后续讲到扩容的时候便会体现出这个区别,这里先透露一下: 使用带了指定长度的构造函数使用的是`EMPTY_ELEMENTDATA`,而默认的空参构造方法使用的是`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`.

构造函数这里就略过了,只是一些初始化操作.下面看点常用方法

**indexOf()**

```java
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i < size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i < size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}
```

`indexOf()`用于查找元素第一次出现的索引,挺简单的.`contains()`复用了这个方法,与之相识的还有`lastIndexOf()`,实现也很简单,只是方向遍历查找值.

**clone()**

```java
public Object clone() {
        try {
            ArrayList<?> v = (ArrayList<?>) super.clone();
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            // this shouldn't happen, since we are Cloneable
            throw new InternalError(e);
        }
    }
```

`ArrayList`的`clone()`只是浅拷贝.并没有去处理对象值的情况.

**add()**

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
```

这个方法算是比较重要的方法,涉及到扩容之类的,上面便是`add()`的定义,比较重要的还是`ensureCapacityInternale()`.我们就着重讲一下该方法,我们假设第一次调用,也就是参数为`1`调用该方法.

```java
private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}
```

`elementData`也就是我们正在存储数据的地方,还记得开头说的`elementData`具体的是`EMPTY_ELEMENTDATA`还是`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`吗?我们把这两种情况都带上:

```java
private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}
```

从上面方法功能看出,如果是`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`则我们这个传递的`1`就被淘汰了,换来的便是默认的`DEFAULT_CAPACITY`,也就是`10`,如果不是则还是我们的`1`,那要是一开始参数就大于默认的`10`,则还是以参数的为准.

```java
 private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}
```

上面判断是否需要扩容,默认第一次初始化为`1-0>0`为`true`,所以,只有在初始化和容器满时才需要扩容.同时`modCount++`记录操作,用于快速失败.

```java
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

把参数带进这个方法便得出扩容结果是多少, 如果是`EMPTY_ELEMENTDATA`,则第一次为`1`, 是`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`则第一次为`10`, 多带入几次, 就会发现如果一开始初始化时如果指定了长度,则使用指定长度的. 如果是指定长度是`0`, 也是会有自动增长的, 但是增长都是从低处开始`1,2,3,4,6....`.相对于使用无参数的构造方式,扩容的大小不是那么大,但前期每次都会扩容.

所,尽量能确定所需要使用的空间,避免扩容发生数组复制.如不能确定,也可以估算一个相对大一点的值.

还有一个`add()`方法,就是在指定位置添加,尽量少使用该方法,因为每次都会进行数组复制.

**remove()**

```java
public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
```

`remove()`没什么好说的,就是把后面的往前移动一个位置. 这也看出每次复制都会进行数组复制.还有一个`remove()`的重载方法就是删除指定的元素,这个效率更低了,因为还多了层遍历操作.

还有一个比较重要的就是`iterator()`方法,这一块涉及到`fail-fast`机制:

**iterator()**

`iterator()`方法属于`iterable`接口定义的,上面也说了,实现`iterable`接口就可以成为`for-each`的目标对象,也就是诸如下面这种形式:

```java
for(String str:list){}
```

如果没有实现`iterable`是不能成为该目标的,我们可以自己尝试下:

```java
// 编译通过
public class Demo implements Iterable<String>{
    public static void main(String[] args) {
        Demo demo = new Demo();
        for (String s : demo) {}
    }
    @Override
    public Iterator<String> iterator() {
        return null;
    }
}
// 编译失败
public class Demo{
    public static void main(String[] args) {
        Demo demo = new Demo();
        for (String s : demo) {}
    }
}

```

而这种形式也就是`Java`的语法糖,除去语法糖就是下面这种形式:

```java
Iterator var2 = list.iterator();
while(var2.hasNext()) {
     String s = (String)var2.next();
     list.remove(s);
}
```

`Iterator` 就是集合的一个迭代器,从`Doc`注释来看,这个迭代器替换了` Enumeration`, 比`Enumeration`有两个不同之处:

1. 允许在迭代的时候删除元素.
2. 改进的方法名称.

接下类看下`ArrayList`的实现:



