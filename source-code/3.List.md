

# List

> 从这篇开始写关于`Java`容器相关的,主要分为三类:`List`,`Set`,`Map`.目前来看只会涉及主要的实现,但也不排除穿插'老家伙'的情况.

## 1.Collection

既然要写容器,那肯定先从`Collection`入手,`Collection`是`List`和`Set`的父接口.`Map`则是单独的接口.在这里提下`Collection`,后面就不再赘述了.

```java
public interface Collection<E> extends Iterable<E> {
```

`Collection`继承`Iterable`接口,实现了`Iterable`就表示允许该对象成为`for-each`的目标对象,者也是`Java`的一个语法糖.该类就包含一个个返回`Iterator`的方法和两个接口默认方法,具体可以自行查看.

`Collection`作为`List`,`Set`接口的根接口,并没有什么实质性的内容,只是定义了些通用方法用户在不同类型中传参,具体的内部细节有子类去掌控,如是否允许为空之类的.而且`JDK`也没有提供该接口的具体实现.

## 2. List

```java
public interface List<E> extends Collection<E> {
```

以上便是`List`接口的定义信息,从官方文档注释来看,`List`代表的是有序的集合,可以精确的控制每个元素的插入位置,可以通过整数索引获取指定位置的元素.并且允许重复,可以有多个`null`值或不为`null`,取决于具体的实现.

官方还提示了一点,在你不知道`List`的具体类型的情况下,迭代列表比通过索引获取更加可取.同时需要慎用通过索引获取元素,这将执行高代价的线性搜索.

## 3.ArrayLsit

### 1. 概览

`ArrayList`可以说是老大哥的存在,绝大部分情况下`List`实现首选,先看下结构:

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
```
先看下`ArrayList`所继承的类:
```java
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
```
`AbstractList`提供了`List`接口的基本实现,以减少使用随机访问(数组)实现`Lsit`接口所需的工作.

上一层

```java
public abstract class AbstractCollection<E> implements Collection<E> {
```

`AbstractCollection`提供了`Collection`的基本实现,以减少实现该接口所需要的工作.如果你只需要实现一个不可修改的集合,那么扩展该类即可,只需重写`iterator()`和`size()`即可,要实现可修改的,那么你还需要重写`add()`方法,因为该`add()`方法默认抛出异常.

`AsbtractCollection`和`AbstractList`的区别就是一个是针对需要实现`Collection`服务的,一个是针对使用数组实现`List`服务的.

再回到`ArrayList`,实现了`RandomAccess`接口,该接口只是一个标记接口,表示该类支持随机访问,在选择对应算法时就可以通过该接口选择合适的算法.`Cloneable`也是一个标记接口,表示该类支持使用`clone()`方法,如果没有实现`Cloneable`而去调用`clone()`则会产生`CloneNotSupportedException`异常.最后一个`Serializable`就不说了,相信大家都知道.

### 2.方法

上面提了一下`ArrayList`的类定义信息,这里我们先粗略的看一下基本熟悉:

```java
	/**
     * 默认初始容量
     */
    private static final int DEFAULT_CAPACITY = 10;
    /**
     * 慢性膨胀，和下面这个主要用去区分第一次膨胀的大小
     */
    private static final Object[] EMPTY_ELEMENTDATA = {};

    /**
     * 第一次膨胀为DEFAULT_CAPACITY
     */
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    /**
     *	实际存储元素数组 transient不被序列化
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * 数组包含的元素数量
     * @serial
     */
    private int size;
```

刚开始令我疑惑的就是上面的`EMPTY_ELEMENTDATA`和`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`属性,为什么需要两个默认的空数组,后续讲到扩容的时候便会体现出这个区别,这里先透露一下: 使用带了指定长度的构造函数使用的是`EMPTY_ELEMENTDATA`,而默认的空参构造方法使用的是`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`.

构造函数这里就略过了,只是一些初始化操作.下面看点常用方法

**indexOf()**

```java
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i < size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i < size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}
```

`indexOf()`用于查找元素第一次出现的索引,挺简单的.`contains()`复用了这个方法,与之相识的还有`lastIndexOf()`,实现也很简单,只是方向遍历查找值.

**clone()**

```java
public Object clone() {
        try {
            ArrayList<?> v = (ArrayList<?>) super.clone();
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            // this shouldn't happen, since we are Cloneable
            throw new InternalError(e);
        }
    }
```

`ArrayList`的`clone()`只是浅拷贝.并没有去处理对象值的情况.

**add()**

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
```

这个方法算是比较重要的方法,涉及到扩容之类的,上面便是`add()`的定义,比较重要的还是`ensureCapacityInternale()`.我们就着重讲一下该方法,我们假设第一次调用,也就是参数为`1`调用该方法.

```java
private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}
```

`elementData`也就是我们正在存储数据的地方,还记得开头说的`elementData`具体的是`EMPTY_ELEMENTDATA`还是`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`吗?我们把这两种情况都带上:

```java
private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}
```

从上面方法功能看出,如果是`DEFAULTCAPACITY_EMPTY_ELEMENTDATA`则我们这个传递的`1`就被淘汰了,换来的便是默认的`DEFAULT_CAPACITY`,也就是`10`,如果不是则还是我们的`1`,那要是一开始参数就大于默认的`10`,则还是以参数的为准.